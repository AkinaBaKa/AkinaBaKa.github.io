title: 【持续更新】C语言程序设计代码大全
cover: /img/封面Coding.png
index_enable: true
aside_enable: true
archives_enable: true
position: both
top_img: /img/背景Clanguage.png
keywords: 
tags:
 - 代码
 - C语言
 - 程序设计
categories: 代码
date: 2024-07-13
---
# **北理工LeXue乐学题目**
## **图形题**
### 2024.06.25 打印图形"字母G"
 ```
#include <stdio.h>
int main(void)
{
	int num;
	scanf("%d",&num);
	for(int n=0;n<2*num-1;n++)
		printf("G");
	printf("\n");
	for(int y=0;y<num-2;y++)
	{
		printf("G");
		for(int n=0;n<2*num-2;n++)
			printf("+");
		printf("\n");
	}
	printf("G");
	for(int n=0;n<2*num-2-num;n++)
		printf("+");
	for(int n=0;n<num;n++)
		printf("G");
	printf("\n");
	for(int y=0;y<num-2;y++)
	{
		printf("G");
		for(int n=0;n<2*num-3;n++)
			printf("+");
		printf("G\n");
	}
	for(int n=0;n<2*num-1;n++)
		printf("G");
	printf("\n");
	return 0;
}
```
### 2024.06.25 打印图形"LOL"
```
#include <stdio.h>
int main(void)
{
	int num;
	scanf("%d",&num);
	printf("*");
	for(int n=0;n<num;n++)
		printf(" ");
	for(int n=0;n<num;n++)
		printf("*");
	printf(" *\n");
	
	for(int y=0;y<num-2;y++)
	{
		printf("*");
		for(int n=0;n<num;n++)
			printf(" ");
		printf("*");
		for(int n=0;n<num-2;n++)
			printf(" ");
		printf("* *\n");
	}
	for(int n=0;n<num;n++)
		printf("*");
	printf(" ");
	for(int n=0;n<num;n++)
		printf("*");
	printf(" ");
	for(int n=0;n<num;n++)
		printf("*");
	printf("\n");
	return 0;
}
```
### 2024.06.13 打印图形“凹/凸”
```
#include <stdio.h>
int main (void)
{
	int num;
	scanf("%d",&num);
	if(num%2==0)
	{
		for(int n=0;n<num/2;n++)
			printf("*");
		for(int n=0;n<num/2-1;n++)
			printf(" ");
		for(int n=0;n<num/2;n++)
			printf("*");
		printf("\n");
		for(int n=0;n<num/3;n++)
		{
			printf("*");
			for(int m=0;m<num/2-2;m++)
				printf(" ");
			printf("*");
			for(int n=0;n<num/2-1;n++)
				printf(" ");
			printf("*");
			for(int m=0;m<num/2-2;m++)
				printf(" ");
			printf("*");
			printf("\n");
		}
		printf("*");
		for(int m=0;m<num/2-2;m++)
			printf(" ");
		for(int m=0;m<num/2+1;m++)
			printf("*");
		for(int m=0;m<num/2-2;m++)
			printf(" ");
		printf("*");
		printf("\n");
		for(int m=0;m<num/2-1;m++)
		{
			printf("*");
			for(int n=0;n<num*3/2-3;n++)
				printf(" ");
			printf("*");
			printf("\n");
		}
		for(int n=0;n<num*3/2-1;n++)
			printf("*");
		printf("\n");
	}
	else
	{
		for(int n=0;n<num/2-1;n++)
			printf(" ");
		for(int n=0;n<num/2+2;n++)
			printf("*");
		printf("\n");
		for(int n=0;n<num/3;n++)
		{
			for(int n=0;n<num/2-1;n++)
				printf(" ");
			printf("*");
			for(int n=0;n<num/2;n++)
				printf(" ");
			printf("*");
			printf("\n");
		}
		for(int m=0;m<num/2;m++)
			printf("*");
		for(int m=0;m<num/2;m++)
			printf(" ");
		for(int m=0;m<num/2;m++)
			printf("*");
		printf("\n");
		for(int m=0;m<num/2-1;m++)
		{
			printf("*");
			for(int n=0;n<3*(num/2)-2;n++)
				printf(" ");
			printf("*");
			printf("\n");
		}
		for(int n=0;n<3*(num/2);n++)
			printf("*");
		printf("\n");
	}
	return
}
```
### 2024.06.13 打印图形“冰淇淋”
```
#include <stdio.h>
int main (void)
{
	int flor,wide,high;
	scanf("%d %d %d",&flor,&wide,&high);
	//head
	for(int n=0;n<2*(flor-1)+wide/2;n++)
		printf(" ");
	printf("*\n");
	for(int n=0;n<2*(flor-1)+wide/2-1;n++)
		printf(" ");
	printf("***\n");
	//ball
	for(int p=0;p<flor;p++)
	{
		for(int m=0;m<high;m++)
		{
			for(int n=0;n<2*(flor-p-1);n++)
				printf(" ");
			for(int n=0;n<wide+p*4;n++)
				printf("*");
			printf("\n");
		}
	}
	//buttom
	for(int m=0;m<2*(flor-1)+wide/2;m++)
	{
		for(int n=0;n<m;n++)
			printf(" ");
		printf("*");
		for(int n=0;n<4*(flor-1)+wide-2-2*m;n++)
			printf(" ");
		printf("*");
		printf("\n");
	}
	for(int n=0;n<2*(flor-1)+wide/2;n++)
		printf(" ");
	printf("*\n");
	return 0;
}
```


## **应用题**
### 2024.06.11 安全的密码
```
#include <stdio.h>
#include <string.h>
int cirno (char*);
int main(void) 
{
	int num;
	scanf("%d",&num);
	getchar();
	while(num-->0)
	{
		char baka[100]={0};
		gets(baka);
		if(strlen(baka)<6)
			printf("Not Safe\n");
		else
			cirno(baka);
	}
	return 0;
}
int cirno (char* busu)
{
	int nu=0,en=0,es=0,caps=0;
	for(int n=0;n<strlen(busu);n++)
	{
		if((busu[n]>='!'&&busu[n]<='/')||(busu[n]>=':'&&busu[n]<='@')||(busu[n]>='['&&busu[n]<='`')||(busu[n]==' '))
			es=1;
		else if(busu[n]>='0'&&busu[n]<='9')
			nu=1;
		else if(busu[n]>='a'&&busu[n]<='z')
			en=1;
		else if((busu[n]>='A'&&busu[n]<='Z'))
			caps=1;
	}
	//printf("%d %d %d\n",nu,en,es);
	if(nu+en+es+caps==1)
		printf("Not Safe\n");
	else if(nu+en+es+caps==2)
		printf("Medium Safe\n");
	else if(nu+en+es+caps>=3)
		printf("Safe\n");
	return 0;
}
```
### 2024.06.25 大家一起做游戏/小学生
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct node
{
	char busu[6];
	struct node * next;
} NODE;

NODE * head;
NODE * end;
NODE * mid;
void import (char *);
void subtract (int);
int main (void)
{
	int n;
	scanf("%d",&n);
	int baka[n];
	for(int m=0;m<n;m++)
		scanf("%d",&baka[m]);
	mid = (NODE *)malloc( sizeof(NODE) );  
    mid->next = NULL;  
    strcpy(mid->busu,"eijuy");  
    
    head = (NODE *)malloc( sizeof(NODE) );
    head->next = mid;
    strcpy(head->busu,"-1");  
    
    for(int p=0;p<n;p++)
    {
    	char name[100];
    	scanf("%s",name);
    	import(name);
	}

	end = (NODE *)malloc( sizeof(NODE) );  
	head->next->next=end;
    end->next = NULL;  
    strcpy(end->busu,"vrqfb");
    
    for(int q=0;q<n;q++)
    {
    	int flag=0;
    	if(q!=0)
    	{
    		for(int x=q;x>=0;x--)
    			if(baka[x]<baka[q])
    				flag++;
    		subtract(baka[q]-flag);
    	}
    	else
    		subtract(baka[0]);
	}
}
void import (char *name)
{
	while(head->next!=NULL)
        head=head->next;
    NODE* p=(NODE*)malloc(sizeof(NODE));
    strcpy(p->busu,name);
    p->next=NULL;
    head->next=p;
    return 0;
}
void subtract (int baka)
{
	int count=0;
	NODE * p;
	NODE * q;
	p=mid;
	while(count<baka-1)
	{
		p = p->next;
		count++;
	}
	q=p->next;
    p->next=q->next;
    printf("%s %s\n",p->busu,q->next->busu);
    free(q);
    return 0;
}
```
### 2024.06.25 开大招
```
#include <stdio.h>
#include <string.h>//AWQEWAEQWQEE
int judge (char);
int count=1;
int Qcd=0,Wcd=0,Ecd=0,Acd=0;
char lst;
int main()
{
	char skill[1000];
	scanf("%s",skill);
	lst=skill[0];
	for(int n=1;n<strlen(skill);n++)
	{
		judge(skill[n]);
		if(Qcd>0)
			Qcd--;
		if(Wcd>0)
			Wcd--;
		if(Ecd>0)
			Ecd--;
		if(Acd>0)
			Acd--;
		if(count>=6)
			break;
	}
	char bol;
	if(count>5)
		bol='Y';
	else
		bol='N'; 
	printf("%d %c\n",count,bol);
	return 0;
}
int judge (char c)
{
	int bl=0;
	switch(c)
	{
		case 'Q':
			if(Qcd==0)
			{
				bl=1;
				Qcd+=2;
			}
			break;
		case 'W':
			if(Wcd==0)
			{
				bl=1;
				Wcd+=4;
			}
			break;
		case 'E':
			if(Ecd==0)
			{
				bl=1;
				Ecd+=3;
			}
			break;
		case 'A':
			if(Acd==0)
			{
				bl=1;
				Acd+=1;
			}
			break;
	}
	if(bl==1)
		if(c!=lst)
		{
			count++;
			lst=c;
		}
	return 0;
}
```
### 2024.06.25 象棋中的马/没做完
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */  
 
#include<stdio.h>   
int n,m,x,y,a[401][401];  
void dfs(int x,int y,int step);  
int main(){  
    scanf("%d%d",&n,&m);  
    for(int i=0;i<401;i++)  
    for(int j=0;j<401;j++)  
    a[i][j]=-1;//这里初始化-1 表示为无法到达   
    dfs(1,1,0);  
    for(int i=1;i<=n;i++){  
    for(int j=1;j<=m;j++)  
    printf("%5d",a[i][j]);  
    printf("\n");  
    }  
    return 0;  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */ 
}  
void dfs(int x,int y,int step)
{
	if(step>n*m)
	    return 0;
	if(x>m||y>n||x<=0||y<=0)
		return 0;
	if(a[x][y]>step||a[x][y]==-1)
		a[x][y]=step;

	
	
	int dub=step;
	dfs(x+2,y+1,++step);
	step=dub;
	dfs(x+2,y-1,++step);
	step=dub;
	dfs(x-2,y+1,++step);
	step=dub;
	dfs(x-2,y-1,++step);
	step=dub;
	dfs(x+1,y+2,++step);
	step=dub;
	dfs(x-1,y+2,++step);
	step=dub;
	dfs(x+1,y-2,++step);
	step=dub;
	dfs(x-1,y-2,++step);
	return 0;
}
```
### 2024.06.12 凯撒密码
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int change (char*);
int seed (int);
int sort (int*,int);
char* outPut(char*,int);
int main (void)
{
	char Rome[1000];
	char Txt[10000];
	int Num[25];
	scanf("%s",Rome);
	for(int p=0;p<25;p++)
		scanf("%d",&Num[p]);
	int key=sort(Num,seed(change(Rome)));
	getchar();
	gets(Txt);
	puts(outPut(Txt,key));
}
int change (char* str)
{
	int pst=0,now=0,tmp,tot=0;
	for(int n=0;n<strlen(str);n++)
	{
		switch(str[n])
		{
			case 'I':now=1;break;
			case 'V':now=5;break;
			case 'X':now=10;break;
			case 'L':now=50;break;
			case 'C':now=100;break;
			case 'D':now=500;break;
			case 'M':now=1000;break;
			default:break;
		}
		tmp=now;
		if(pst<now&&pst!=0)
			now=now-2*pst;
		pst=tmp;
		tot+=now;
	}
	return tot;
}
int seed (int s)
{
	while(1)
	{
		int sed=0;
		for(int n=1;;n*=10)
		{
			if(s%n==s)
				break;
			sed+=s/n%10;
		}
		s=sed;
		if(sed%10==sed)
			return sed;
	}
}
int sort (int* it,int sed)
{
	for(int i=0;i<25;i++)
	{
		for(int j=0;j<25-i-1;j++)
		{
			if(it[j]>it[j+1])
			{
				int tmp=it[j];
				it[j]=it[j+1];
				it[j+1]=tmp;	
			}
		}
	}
	return it[sed-1];
}
char* outPut(char* txt,int key)
{
	int swch=key%26;
	printf("%d\n",swch);
	for(int n=0;n<strlen(txt);n++)
	{
		if(txt[n]>='a'&&txt[n]<='z')
		{
			if((int)txt[n]+swch>122)
				txt[n]+=(swch-26);
			else
				txt[n]+=swch;
		}
	}
	return txt;
}
```
### 2024.06.11 全能的战士
```
#include<stdio.h>
int main(void){
	int n,n1,n2,n3,n12,n13,n23;
	scanf("%d %d %d %d %d %d %d",&n,&n1,&n2,&n3,&n12,&n13,&n23);
	printf("%d\n",n-(n1+n2+n3-n12-n13-n23));
	return 0;
}
```
### 2024.06.13 最短路径
```
#include <stdio.h>
int main(void)
{
	int x1,y1;
	int x2,y2;
	scanf("%d %d %d %d",&x2,&y2,&x1,&y1);
	if(x1==0&&x2==0&&y1==0&&y2==0)
	{
		printf("1\n(0,0)\n");
		return 0;
	}
	int fst=0,sec=0;
	int mid1,mid2;
	mid1=(x1-1)*(y1-1);
	mid2=(x2-x1-1)*(y2-y1-1);
	if(mid2<0)
		mid2/=-1;
	fst=x1*y1;
	sec=(x2-x1)*(y2-y1);
	if(sec<0)
		sec/=-1;
	printf("%d\n",(fst+1+mid1)*(sec+1+mid2));
	int x=0,y=0;
	for(int n=0;;n++)
	{
		if(x==x1&&y==y1)
			break;
		printf("(%d,%d)",x,y);
		if(x==x1)
			y++;
		else
			x++;
	}
	x=x1,y=y1;
	for(int n=0;;n++)
	{
		printf("(%d,%d)",x,y);
		if(x==x2&&y==y2)
			break;
		if(x==x2)
			y++;
		else
			x++;
	}
	printf("\n");
	return 0;
}
```

## **递归题**
### 2024.06.13 递归函数
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */  
 
#include <stdio.h>  
void PrintChar(int number,char c){  
    int i;  
    for ( i=0 ; i< number; i++)  
        printf("%c",c);  
}  
 
// ????-----------???? 
char RecursionFunction(int n, char c);  
  
int main(){  
    char c; int n;  
    scanf("%d %c",&n,&c);  
    RecursionFunction(n,c);  
    return 0;  
}  
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */  
char RecursionFunction(int n, char c)
{
	if(n<=0)
	{
		printf("\n");
		printf("RecursionFunction has been over !\n");
		return 0;
	}
	PrintChar(n,c);
	switch(c)
	{
		case '#':n-=1;c='*';break;
		case '*':n+=2;c='?';break;
		case '?':n+=3;c='+';break;
		case '+':n-=6;c='#';break;
	}
	RecursionFunction(n,c);
}
```

## **链表题**
### 2024.06.12 链表查找
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */  
  
#include <stdio.h>  
#include <stdlib.h>  
  
int st=0,ed=0;  
typedef struct node  
{   int         data;  
    struct node * next;  
} NODE;  
    
NODE * find( NODE * , int * );  
void outputring( NODE * );  
void change( int , int , NODE * );  
    
void outputring( NODE * pring )  
{  
    NODE * p;  
    p = pring;  
    //printf("ass%d", p->data);  
    if ( p == NULL )  
        printf("NULL");  
    else  
        do  
        {  
            printf("%d", p->data);  
            p = p->next;  
            if(p==NULL){  
                break;  
            }  
        }while(p!= pring);  
    printf("\n");  
    return;  
    
}  
    
int main()  
{   int n, m;  
    NODE * head, * pring;  
    
    scanf("%d%d", &n, &m);  
    head = (NODE *)malloc( sizeof(NODE) );  
    head->next = NULL;  
    head->data = -1;  
    
    change( n, m, head );  
    pring = find( head, &n );  
    printf("ring=%d\n", n);  
    outputring( pring );  
    
    return 0;  
}  
    
/* Here is waiting for you. 
void change( int n, int m, NODE * head ) 
{ 
} 
  
NODE * find( NODE * head, int * n ) 
{ 
} 
*/  
    
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */  
void change( int n, int m, NODE * head )  
{  
    int sh[1000]={0};  
    int mo[1000]={0};  
    int bl=0;  
    for(int i=0;;i++)  
    {  
        sh[i]=n*10/m;  
        mo[i]=n*10%m;  
        for(int j=0;j<i;j++)  
            if(sh[i]==sh[j]&&mo[i]==mo[j])  
            {  
                st=j;  
                ed=i;  
                bl=1;  
                break;  
            }  
        n=mo[i];  
          
          
        if(n==0)  
        {  
            st=i+1;  
            break;  
        }  
        if(bl!=0)  
            break;  
    }  
      
    for(int k=0;k<st;k++)  
    {  
        while(head->next!=NULL)  
            head=head->next;  
        NODE* p=(NODE*)malloc(sizeof(NODE));  
        p->data=sh[k];  
        p->next=NULL;  
        head->next=p;  
    }  
    if(bl!=0)  
    {  
        for(int k=st;k<ed;k++)  
        {  
            while(head->next!=NULL)  
                head=head->next;  
            NODE* p=(NODE*)malloc(sizeof(NODE));  
            p->data=sh[k];  
            p->next=NULL;  
            head->next=p;  
        }  
    }  
}  
  
NODE * find( NODE * head, int * n )  
{  
    if(ed>st)  
    {  
        *n=ed-st;  
        NODE* a=head->next;  
        for(int k=0;k<st;k++)  
            a=a->next;  
        //printf("ass%d",a->data);  
        return a;  
    }  
    else  
    {  
        *n=0;  
        return NULL;  
    }  
}
```
### 2024.06.11 链表小数节点
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */
 
#include <stdio.h>
#include <stdlib.h>

int st=0,ed=0;
typedef struct node
{   int         data;
    struct node * next;
} NODE;
  
NODE * find( NODE * , int * );
void outputring( NODE * );
void change( int , int , NODE * );
  
void outputring( NODE * pring )
{
    NODE * p;
    p = pring;
    //printf("ass%d", p->data);
    if ( p == NULL )
        printf("NULL");
    else
        do
        {
            printf("%d", p->data);
            p = p->next;
            if(p==NULL){
                break;
            }
        }while(p!= pring);
    printf("\n");
    return;
  
}
  
int main()
{   int n, m;
    NODE * head, * pring;
  
    scanf("%d%d", &n, &m);
    head = (NODE *)malloc( sizeof(NODE) );
    head->next = NULL;
    head->data = -1;
  
    change( n, m, head );
    pring = find( head, &n );
    printf("ring=%d\n", n);
    outputring( pring );
  
    return 0;
}
  
/* Here is waiting for you.
void change( int n, int m, NODE * head )
{
}
 
NODE * find( NODE * head, int * n )
{
}
*/
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
void change( int n, int m, NODE * head )
{
    int sh[1000]={0};
    int mo[1000]={0};
    int bl=0;
    for(int i=0;;i++)
    {
        sh[i]=n*10/m;
        mo[i]=n*10%m;
        for(int j=0;j<i;j++)
            if(sh[i]==sh[j]&&mo[i]==mo[j])
            {
                st=j;
                ed=i;
                bl=1;
                break;
            }
        n=mo[i];
        
        
        if(n==0)
        {
            st=i+1;
            break;
        }
        if(bl!=0)
            break;
    }
    
    for(int k=0;k<st;k++)
    {
        while(head->next!=NULL)
            head=head->next;
        NODE* p=(NODE*)malloc(sizeof(NODE));
        p->data=sh[k];
        p->next=NULL;
        head->next=p;
    }
    if(bl!=0)
    {
        for(int k=st;k<ed;k++)
        {
            while(head->next!=NULL)
                head=head->next;
            NODE* p=(NODE*)malloc(sizeof(NODE));
            p->data=sh[k];
            p->next=NULL;
            head->next=p;
        }
    }
}

NODE * find( NODE * head, int * n )
{
    if(ed>st)
    {
        *n=ed-st;
        NODE* a=head->next;
        for(int k=0;k<st;k++)
            a=a->next;
        //printf("ass%d",a->data);
        return a;
    }
    else
    {
        *n=0;
        return NULL;
    }
}
```


# **其他**
## emm暂无,The Akina histroy goes on~
