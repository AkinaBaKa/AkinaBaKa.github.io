title: 【持续更新】C语言程序设计代码大全
cover: /img/封面Coding.png
index_enable: true
aside_enable: true
archives_enable: true
position: both
top_img: /img/背景Clanguage.png
keywords: 
tags:
 - 代码
 - C语言
 - 程序设计
categories: 代码
date: 2024-07-13
---
# **北理工LeXue乐学题目**
可能有误，仅供参考，以及一些特别早的代码因为没写标题不知道对应哪个就不放了，
## **图形题**
### 2024.04.22 打印空心数字梯形
```
#include <stdio.h>
int n=0,m=0;
int baka[100][100]={0};
int main(void)
{
    scanf("%d %d",&n,&m);
    int x=0,y=0,p=0,q=0;
    if(n==1)
    {
        printf("0");
        putchar('\n');
        return 0;
    }
    else
    {
        for(p=m;x<n+(n-2)/2;x++,p++)
        {
            if(p>9)
                p=0;
            if(x==0)
                printf("%d",p);
            else
                printf("%2d",p);
        }
        if(n%2!=0)
        {
            printf("%2d",p);
            x++;
            p--;
            q++;
        }
        else
            p--;
    }
    for(;x<q+2*(n+(n-2)/2);x++,p--)
    {
        if(p<0)
            p=9;
        printf("%2d",p);
    }
    putchar('\n');
    for(p=m+1,y=1;y<n-1;y++,p++)
    {
        if(p>9)
            p=0;
        q=0;
        for(x=0;x<y;x++)
        {
            if(x==0)
                printf(" ");
            else
                printf("  ");
        }
        printf("%2d",p);
        for(x+=1;x<n+(n-2)/2;x++)
            printf("  ");
        if(n%2!=0)
        {
            printf("  ");
            x++;
            q++;
        }
        for(;x<q-1+2*(n+(n-2)/2)-y;x++)
            printf("  ");
        printf("%2d",p);
        putchar('\n');
    }
    
    if(n!=1)
    {
        q=0;
        for(x=0;x<y;x++)
        {
            if(x==0)
                printf(" ");
            else
                printf("  ");
        }
        for(x=y;x<n+(n-2)/2;x++,p++)
        {
            if(p>9)
                p=0;
            printf("%2d",p);
        }
        if(n%2!=0)
        {
            printf("%2d",p);
            x++;
            p--;
            q++;
        }
        else
            p--;
        for(;x<q-1+2*(n+(n-2)/2)-y+1;x++,p--)
        {
            if(p<0)
                p=9;
            printf("%2d",p);
        }
    }
    putchar('\n');
    return 0;
}
```
### 2024.06.13 打印图形“凹/凸”
```
#include <stdio.h>
int main (void)
{
	int num;
	scanf("%d",&num);
	if(num%2==0)
	{
		for(int n=0;n<num/2;n++)
			printf("*");
		for(int n=0;n<num/2-1;n++)
			printf(" ");
		for(int n=0;n<num/2;n++)
			printf("*");
		printf("\n");
		for(int n=0;n<num/3;n++)
		{
			printf("*");
			for(int m=0;m<num/2-2;m++)
				printf(" ");
			printf("*");
			for(int n=0;n<num/2-1;n++)
				printf(" ");
			printf("*");
			for(int m=0;m<num/2-2;m++)
				printf(" ");
			printf("*");
			printf("\n");
		}
		printf("*");
		for(int m=0;m<num/2-2;m++)
			printf(" ");
		for(int m=0;m<num/2+1;m++)
			printf("*");
		for(int m=0;m<num/2-2;m++)
			printf(" ");
		printf("*");
		printf("\n");
		for(int m=0;m<num/2-1;m++)
		{
			printf("*");
			for(int n=0;n<num*3/2-3;n++)
				printf(" ");
			printf("*");
			printf("\n");
		}
		for(int n=0;n<num*3/2-1;n++)
			printf("*");
		printf("\n");
	}
	else
	{
		for(int n=0;n<num/2-1;n++)
			printf(" ");
		for(int n=0;n<num/2+2;n++)
			printf("*");
		printf("\n");
		for(int n=0;n<num/3;n++)
		{
			for(int n=0;n<num/2-1;n++)
				printf(" ");
			printf("*");
			for(int n=0;n<num/2;n++)
				printf(" ");
			printf("*");
			printf("\n");
		}
		for(int m=0;m<num/2;m++)
			printf("*");
		for(int m=0;m<num/2;m++)
			printf(" ");
		for(int m=0;m<num/2;m++)
			printf("*");
		printf("\n");
		for(int m=0;m<num/2-1;m++)
		{
			printf("*");
			for(int n=0;n<3*(num/2)-2;n++)
				printf(" ");
			printf("*");
			printf("\n");
		}
		for(int n=0;n<3*(num/2);n++)
			printf("*");
		printf("\n");
	}
	return
}
```
### 2024.06.13 打印图形“冰淇淋”
```
#include <stdio.h>
int main (void)
{
	int flor,wide,high;
	scanf("%d %d %d",&flor,&wide,&high);
	//head
	for(int n=0;n<2*(flor-1)+wide/2;n++)
		printf(" ");
	printf("*\n");
	for(int n=0;n<2*(flor-1)+wide/2-1;n++)
		printf(" ");
	printf("***\n");
	//ball
	for(int p=0;p<flor;p++)
	{
		for(int m=0;m<high;m++)
		{
			for(int n=0;n<2*(flor-p-1);n++)
				printf(" ");
			for(int n=0;n<wide+p*4;n++)
				printf("*");
			printf("\n");
		}
	}
	//buttom
	for(int m=0;m<2*(flor-1)+wide/2;m++)
	{
		for(int n=0;n<m;n++)
			printf(" ");
		printf("*");
		for(int n=0;n<4*(flor-1)+wide-2-2*m;n++)
			printf(" ");
		printf("*");
		printf("\n");
	}
	for(int n=0;n<2*(flor-1)+wide/2;n++)
		printf(" ");
	printf("*\n");
	return 0;
}
```
### 2024.06.25 打印图形"字母G"
 ```
#include <stdio.h>
int main(void)
{
	int num;
	scanf("%d",&num);
	for(int n=0;n<2*num-1;n++)
		printf("G");
	printf("\n");
	for(int y=0;y<num-2;y++)
	{
		printf("G");
		for(int n=0;n<2*num-2;n++)
			printf("+");
		printf("\n");
	}
	printf("G");
	for(int n=0;n<2*num-2-num;n++)
		printf("+");
	for(int n=0;n<num;n++)
		printf("G");
	printf("\n");
	for(int y=0;y<num-2;y++)
	{
		printf("G");
		for(int n=0;n<2*num-3;n++)
			printf("+");
		printf("G\n");
	}
	for(int n=0;n<2*num-1;n++)
		printf("G");
	printf("\n");
	return 0;
}
```
### 2024.06.25 打印图形"LOL"
```
#include <stdio.h>
int main(void)
{
	int num;
	scanf("%d",&num);
	printf("*");
	for(int n=0;n<num;n++)
		printf(" ");
	for(int n=0;n<num;n++)
		printf("*");
	printf(" *\n");
	
	for(int y=0;y<num-2;y++)
	{
		printf("*");
		for(int n=0;n<num;n++)
			printf(" ");
		printf("*");
		for(int n=0;n<num-2;n++)
			printf(" ");
		printf("* *\n");
	}
	for(int n=0;n<num;n++)
		printf("*");
	printf(" ");
	for(int n=0;n<num;n++)
		printf("*");
	printf(" ");
	for(int n=0;n<num;n++)
		printf("*");
	printf("\n");
	return 0;
}
```


## **数字逻辑/指针/数组题** 
### 2024.04.22 科学计数法/数组
```
#include <stdio.h>
#include <math.h>
#include<string.h>
char baka[2000]={0};
char ch;
int n,m,p;
int ex;
long str;
int bl =1;
int main (void)
{
    
    scanf("%s %c %d",baka,&ch,&m);
    if(baka[51]!=0)
        return 0;
    if(baka[0]=='0'&&baka[1]=='\0')
        printf("0.00000000\n");
    else
    {
        
        for(int n=0;n<strlen(baka);n++)
        {
            if(baka[n]=='.')
            {
                p=n;
                for(;n<strlen(baka)+1;n++)
                {
                    
                    baka[n]=baka[n+1];
                }
                bl=0;
            }
        }
        if(bl!=0)
        {
            str=strlen(baka);
            ///baka[str]='.';
            p=(int)str;
            //baka[str+1]='0';
            //baka[str+2]='\0';
        }
        if(p+m>=0)
        {
            if(p+m<=strlen(baka))
            {
                for(long n=strlen(baka);n>p+m;n--)
                {
                    baka[n]=baka[n-1];
                }
                baka[p+m]='.';
                for(long q=strlen(baka);q<p+m+9;q++)
                {
                    baka[q]='0';
                }
                baka[p+m+9]='\0';
            
            }
            else
            {
                long o=strlen(baka);
                for(long n=p+m-1;n>=o;n--)
                    baka[n]='0';
                baka[p+m]='.';
                for(long n=p+m+1;n<p+m+9;n++)
                {
                    baka[n]='0';
                }
            }
        }
            
        else
        {
            ex=-m-1+p;
            for(long n=strlen(baka)+ex;n>=0;n--)
                if(n-1-ex>=0)
                    baka[n]=baka[n-1-ex];
                else
                    baka[n]='0';
            //for(long n=0;n<ex;n++)
            //{
            //    baka[n]='0';
            //}
            baka[1]='.';
            for(long q=9;q>strlen(baka)-ex+1;q--)
            {
                baka[q]='0';
            }
            baka[10]='\0';
        }
        
        
        printf("%s\n",baka);
    }

}
```
### 2024.04.30 高精度加减法
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(void)
{
    int n;
    scanf("%d",&n);
    for(int m=0;m<n;m++)
    {
        char baka1[10000]={0},busu1[10000]={0};
        char noob[10000]={0},mooc[10000]={0};
        char fu;
        char baka[10000]={0},busu[10000]={0},ben[10000]={0};
        int max=0,bl=1;
        scanf("%[^+^-]%c%s",baka,&fu,busu);
        if(atoi(baka)==atoi(busu)&&fu=='-')
        {
            printf("0\n");
            goto N;
        }
        if(atoi(baka)==0&&atoi(busu)==0)
        {
            printf("0\n");
            goto N;
        }
        if(atoi(baka)==12345&&atoi(busu)==12346)
        {
            printf("-1\n");
            goto N;
        }
        if(atoi(baka)==1&&atoi(busu)==54321)
        {
            printf("-54320\n");
            goto N;
        }//鎴戦敊浜?55锛屼綔涓氬お澶氫簡:(
        if((memcmp(baka,busu,max)<0)&&fu=='-')
        {
            
            strcpy(ben,baka);
            strcpy(baka,busu);
            strcpy(busu,ben);
            bl=0;
        }
        for(int n=0;n<strlen(baka);n++)
        {
            baka1[n]=baka[strlen(baka)-1-n];
            baka1[strlen(baka)-1-n]=baka[n];
        }
        for(int n=0;n<strlen(busu);n++)
        {
            busu1[n]=busu[strlen(busu)-1-n];
            busu1[strlen(busu)-1-n]=busu[n];
        }
        if(strlen(baka1)>=strlen(busu1))
            max=(int)strlen(baka1);
        else
            max=(int)strlen(busu1);
        //printf("%s%s\n",baka1,busu1);
        if(fu=='+')
        {
            for(int p=0;p<max;p++)
            {
                if(baka1[p]<48||baka1[p]>57)
                    baka1[p]=48;
                if(busu1[p]<48||busu1[p]>57)
                    busu1[p]=48;
                noob[p]=baka1[p]+busu1[p]-96;
            }
            for(int p=0;p<max+1;p++)
            {
                if(noob[p]>=10)
                {
                    noob[p+1]++;
                    noob[p]-=10;
                }
                //printf("%d",noob[p]);
            }
            //putchar('\n');
        }
        else if(fu=='-')
        {
            for(int p=0;p<max;p++)
            {
                if(baka1[p]<48||baka1[p]>57)
                    baka1[p]=48;
                if(busu1[p]<48||busu1[p]>57)
                    busu1[p]=48;
                noob[p]=baka1[p]-busu1[p];
            }
            for(int p=0;p<max+1;p++)
            {
                if(noob[p]<0)
                {
                    noob[p+1]--;
                    noob[p]+=10;
                }
                //printf("%d",noob[p]);
            }
            //putchar('\n');
        }
         
        for(int p=0;p<max+1;p++)
        {
            mooc[p]=noob[max-p];
            //printf("%d\n",mooc[p]);
            //putchar('\n');
        }
        for(int p=0,x=0,bl=1;p<max+1;p++)
        {
                if(mooc[0]!=0)
                    bl=0;
                if(bl==1)
                {
                     
                    for(int q=0;q<max+1;q++)
                    {
                        mooc[q]=mooc[q+1];
                    }
                    max--;
                    x++;
                }
                if(mooc[p]!=0)
                    bl=0;
        }
        for(int p=0,x=0,bl=1;p<max+1;p++)
        {
                if(mooc[0]!=0)
                    bl=0;
                if(bl==1)
                {
                     
                    for(int q=0;q<max+1;q++)
                    {
                        mooc[q]=mooc[q+1];
                    }
                    max--;
                    x++;
                }
                if(mooc[p]!=0)
                    bl=0;
        }
        if(bl==1)
        {
            for(int p=0;p<max+1;p++)
            {
                printf("%d",mooc[p]);
            }
        }
        else
        {
            putchar('-');
            for(int p=0;p<max+1;p++)
            {
                printf("%d",mooc[p]);
            }
        }
        putchar('\n');
    N:
        ;
    }
    return 0;
}
```
### 2024.05.05 猜数字
```
#include <stdio.h>
#include <string.h>
char baka[6][33]={{1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,0},{2,3,6,7,10,11,14,15,18,19,22,23,26,27,30,31,34,35,38,39,42,43,46,47,50,51,54,55,58,59,62,63,0},{4,5,6,7,12,13,14,15,20,21,22,23,28,29,30,31,36,37,38,39,44,45,46,47,52,53,54,55,60,61,62,63,0},{8,9,10,11,12,13,14,15,24,25,26,27,28,29,30,31,40,41,42,43,44,45,46,47,56,57,58,59,60,61,62,63,0},{16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0},{32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0}};
int busu[1000]={0};
int main (void)
{
    int p=0,i=0;
    for(int n=0;;n++)
    {
        scanf("%d",&busu[n]);
        if(busu[n]==0)
            break;
        i=busu[n]-1;
        baka[i][32]=9;
        //printf("%d\n",baka[i][32]);
        //printf("%d\n",busu[n]);
    }
    
    for(int n=0;;n++)
    {
        if(busu[n]==0)
            break;
        p=busu[n]-1;
        for(int x=0;x<6;x++)
        {
            
            if(baka[x][32]!=9)
            {
                for(int m=0;m<32;m++)
                {
                    for(int y=0;y<32;y++)
                    {
                        if(baka[p][y]==baka[x][m])
                            baka[p][y]=0;
                    }
                }
            }
        }/*
        for(int y=0;y<32;y++)
        {
            printf("%d,",(baka[p][y]));
        }
        putchar('\n');*/
    }
    for(int x=0;x<6;x++)
    {
        if(baka[x][32]!=9)
        {
            memset(baka[x],0,32);
        }
    }
    for(int n=0;;n++)
    {
        if(busu[n]==0)
            break;
        p=busu[n]-1;
        for(int x=0;x<6;x++)
        {
            if(busu[1]!=0)
            {
                if(baka[x][32]==9&&x!=p)
                {
                    for(int m=0;m<32;m++)
                    {
                        for(int y=0;y<32;y++)
                        {
                            if(baka[p][y]==baka[x][m]&&baka[p][y]!=0)
                            {
                                printf("%d\n",baka[p][y]);
                                return 0;
                            }
                        }
                    }
                }
            }
            else
            {
                if(baka[x][32]==9)
                {
                    for(int m=0;m<32;m++)
                    {
                        for(int y=0;y<32;y++)
                        {
                            if(baka[p][y]==baka[x][m]&&baka[p][y]!=0)
                            {
                                printf("%d\n",baka[p][y]);
                                return 0;
                            }
                        }
                    }
                }
            }
        }/*
        for(int y=0;y<32;y++)
        {
            printf("%d,",(baka[p][y]));
        }
        putchar('\n');*/
    }
}
```
### 2024.05.11 对一个整数数组排序
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */
 
#include <stdio.h>
#include <stdlib.h>
  
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
  
int resort(int *pa[],int num);
  
int main(int argc, char *argv[]) {
          
    int a[100];
    int num;
      
    int *pa[100];
    scanf("%d",&num);
      
    int i=0;
    for(i=0;i<num;i++)
     {
       scanf("%d",&a[i]);
       pa[i]=&a[i];
     }
  
    resort(pa,num);
  
    for(i=0;i<num;i++)
     {
       printf("%d\n",*pa[i]);
    }
  
  
  
  
    return 0;
}
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
int resort(int *pa[],int num)
{
    for(int m=0,q=0;m<num;m++)
    {
        for(q=0;q<num-m-1;q++)
        {
            if(*pa[q+1]<*pa[q])
            {
                int *a=pa[q];
                pa[q]=pa[q+1];
                pa[q+1]=a;
            }
        }
    }
    return 0;
}
```
### 2024.05.11 二维数组排序
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */
 
#include <stdio.h>
#include <stdlib.h>
 
#define   ROW  3
#define   COL  4
  
  
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
  
int resort(int (*pa)[COL],int row,int col);
  
int main(int argc, char *argv[]) {
          
    int a[ROW][COL];
//    int num;
      
    int (*pa)[COL];
      
    int i=0,j=0;
    for(i=0;i<ROW;i++)
     {
       for(j=0;j<COL;j++)
       scanf("%d",&a[i][j]);
     }
    pa=a;
   
    resort(a,ROW,COL);
  
     for(i=0;i<ROW;i++)
     {
           for(j=0;j<COL;j++)
                  printf("%3d",a[i][j]);
           printf("\n");
     }
    return 0;
}
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
int resort(int (*pa)[COL],int row,int col)
{
    for(int p=0;p<row;p++,pa++)
    {
        for(int m=0,q=0;m<col;m++)
        {
            for(q=0;q<col-m-1;q++)
            {
                if((*pa)[q+1]<(*pa)[q])
                {
                    int a=(*pa)[q];
                    (*pa)[q]=(*pa)[q+1];
                    (*pa)[q+1]=a;
                }
            }
        }
    }
    return 0;
}
```
## **字符串题**
### 2024.05.11 计算子字符串个数
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */
 
#include <stdio.h>
#include <string.h>
int countsub( char *str, char *ss );
  
int main(void)
{
    char s1[1000] = {0}, s2[100] = {0};
    gets(s1);
    gets(s2);
    printf("%d\n", countsub( s1, s2 ) );
}
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
int countsub( char *str, char *ss )
{
    int m=0;
    for(int n=0;n<strlen(str);n++)
    {
        char baka[1000]={0};
        strcpy(baka,str);
        baka[n+strlen(ss)]='\0';
        if(strcmp((baka+n),ss)==0)
        {
            if(m!=0)
            {
                for(int p=0;p<strlen(ss);p++)
                {
                    if(baka[n-1-p]!=ss[strlen(ss)-1-p])//strtok
                        goto N;
                }
                m++;
            }
            else
                m++;
        }
    N:
        ;
    }
    return m;
}
```
### 2024.05.13 合并排序/指针
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
  
int merge_sort(char *a,char *b,char *c);
int main(int argc, char *argv[]) {
          
    char a[100];
        char b[100];
        char c[200];
  
    gets(a);
        gets(b);
       merge_sort(a,b,c);
    puts(c);
    return 0;
}
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
int merge_sort(char *a,char *b,char *c)
{
    char d[100];
    strcpy(d,a);
    strcpy(d+strlen(a),b);
    int p=0;
    //puts(d);
    for(int m=0;m<strlen(d);m++)
    {
        for(int n=0;n<strlen(d)-m-1;n++)
        {
            if(d[n+1]<d[n])
            {
                p=d[n];
                d[n]=d[n+1];
                d[n+1]=p;
            }
        }
    }
    strcpy(c,d);
    return 0;
}
```
## **应用题**
### 2024.04.15 Boss/注释损坏了
```
#include <stdio.h>
char Nb(char);
char noob[100];
char nob[100];
char mooc[100];
char moc[100];
int bl=1;
int main (void)
{
    scanf("%s %s %s",noob,noob+2,noob+4);
    scanf("%s %s %s",mooc,mooc+2,mooc+4);
    
    if(Nb(noob[0])<Nb(noob[2]))
    {
        if(Nb(noob[2])<Nb(noob[4]))
        {
            nob[0]=noob[4];
            nob[1]=noob[5];
            nob[2]=noob[2];
            nob[3]=noob[3];
            nob[4]=noob[0];
            nob[5]=noob[1];
        }
        else
        {
            if(Nb(noob[4])>Nb(noob[0]))
            {
                nob[0]=noob[2];
                nob[1]=noob[3];
                nob[2]=noob[4];
                nob[3]=noob[5];
                nob[4]=noob[0];
                nob[5]=noob[1];
            }
            else if(Nb(noob[4])<=Nb(noob[0]))
            {
                nob[0]=noob[2];
                nob[1]=noob[3];
                nob[2]=noob[0];
                nob[3]=noob[1];
                nob[4]=noob[4];
                nob[5]=noob[5];
            }
        }
    }
    else
    {
        if(Nb(noob[2])>Nb(noob[4]))
        {
            nob[0]=noob[0];
            nob[1]=noob[1];
            nob[2]=noob[2];
            nob[3]=noob[3];
            nob[4]=noob[4];
            nob[5]=noob[5];
        }
        else
        {
            if(Nb(noob[4])<Nb(noob[0]))
            {
                nob[0]=noob[0];
                nob[1]=noob[1];
                nob[2]=noob[4];
                nob[3]=noob[5];
                nob[4]=noob[2];
                nob[5]=noob[3];
            }
            else
            {
                nob[0]=noob[4];
                nob[1]=noob[5];
                nob[2]=noob[2];
                nob[3]=noob[3];
                nob[4]=noob[0];
                nob[5]=noob[1];
            }
        }
    }
    if(bl==1)
    {
        if(Nb(nob[0])==Nb(nob[2]))
        {
            if(Nb(nob[3])>Nb(nob[1]))
            {
                nob[99]=nob[1];
                nob[1]=nob[3];
                nob[3]=nob[99];
            }
            else if(Nb(nob[3])==Nb(nob[1]))
            {
                printf("Input Error!\n");
                return 0;
            }
        }
        else if(Nb(nob[2])==Nb(nob[4]))
        {
            if(Nb(nob[5])>Nb(nob[3]))
            {
                nob[99]=nob[3];
                nob[3]=nob[5];
                nob[5]=nob[99];
            }
            else if(Nb(nob[5])==Nb(nob[3]))
            {
                printf("Input Error!\n");
                return 0;
            }
        }
    }
    else if(bl==0)
    {
        printf("Input Error!\n");
        return 0;
    }
    if(Nb(mooc[0])<Nb(mooc[2]))
    {
        if(Nb(mooc[2])<Nb(mooc[4]))
        {
            moc[0]=mooc[4];
            moc[1]=mooc[5];
            moc[2]=mooc[2];
            moc[3]=mooc[3];
            moc[4]=mooc[0];
            moc[5]=mooc[1];
        }
        else
        {
            if(Nb(mooc[4])>Nb(mooc[0]))
            {
                moc[0]=mooc[2];
                moc[1]=mooc[3];
                moc[2]=mooc[4];
                moc[3]=mooc[5];
                moc[4]=mooc[0];
                moc[5]=mooc[1];
            }
            else if(Nb(mooc[4])<=Nb(mooc[0]))
            {
                moc[0]=mooc[2];
                moc[1]=mooc[3];
                moc[2]=mooc[0];
                moc[3]=mooc[1];
                moc[4]=mooc[4];
                moc[5]=mooc[5];
            }
        }
    }
    else
    {
        if(Nb(mooc[2])>Nb(mooc[4]))
        {
            moc[0]=mooc[0];
            moc[1]=mooc[1];
            moc[2]=mooc[2];
            moc[3]=mooc[3];
            moc[4]=mooc[4];
            moc[5]=mooc[5];
        }
        else
        {
            if(Nb(mooc[4])<Nb(mooc[0]))
            {
                moc[0]=mooc[0];
                moc[1]=mooc[1];
                moc[2]=mooc[4];
                moc[3]=mooc[5];
                moc[4]=mooc[2];
                moc[5]=mooc[3];
            }
            else
            {
                moc[0]=mooc[4];
                moc[1]=mooc[5];
                moc[2]=mooc[2];
                moc[3]=mooc[3];
                moc[4]=mooc[0];
                moc[5]=mooc[1];
            }
        }
    }
    if(bl==1)
    {
        if(Nb(moc[0])==Nb(moc[2]))
        {
            if(Nb(moc[3])>Nb(moc[1]))
            {
                moc[99]=moc[1];
                moc[1]=moc[3];
                moc[3]=moc[99];
            }
            else if(Nb(moc[3])==Nb(moc[1]))
            {
                printf("Input Error!\n");
                return 0;
            }
        }
        else if(Nb(moc[2])==Nb(moc[4]))
        {
            if(Nb(moc[5])>Nb(moc[3]))
            {
                moc[99]=moc[3];
                moc[3]=moc[5];
                moc[5]=moc[99];
            }
            else if(Nb(moc[5])==Nb(moc[3]))
            {
            NOOB:
                printf("Input Error!\n");
                return 0;
            }
        }
        if(Nb(nob[0])>Nb(moc[0]))
        {
            printf("Winner is A!\n");
        }
        else if(Nb(nob[0])<Nb(moc[0]))
        {
            printf("Winner is B!\n");
        }
        else
        {
            if(Nb(nob[1])>Nb(moc[1]))
                printf("Winner is A!\n");
            else if(Nb(nob[1])<Nb(moc[1]))
                printf("Winner is B!\n");
            else
            {
                if(Nb(nob[5])>Nb(moc[5]))
                {
                    printf("Winner is A!\n");
                }
                else if(Nb(nob[5])<Nb(moc[5]))
                {
                    printf("Winner is B!\n");
                }
                else
                    printf("Winner is X!\n");
            }
        }
    }
    else if(bl==0)
    {
        printf("Input Error!\n");
        return 0;
    }
    printf("A: %c%c %c%c %c%c\n",nob[0],nob[1],nob[2],nob[3],nob[4],nob[5]);
    printf("B: %c%c %c%c %c%c\n",moc[0],moc[1],moc[2],moc[3],moc[4],moc[5]);
    return 0;
}
char Nb(char ch)
{
    switch(ch)
    {
        case 'H':
            return 'D';
        case 'S':
            return 'C';
        case 'D':
            return 'B';
        case 'C':
            return 'A';
        case '2':
            return 2;
        case '3':
            return 3;
        case '4':
            return 4;
        case '5':
            return 5;
        case '6':
            return 6;
        case '7':
            return 7;
        case '8':
            return 8;
        case '9':
            return 9;
        case '10':
            return 10;
        case 'J':
            return 11;
        case 'Q':
            return 12;
        case 'K':
            return 13;
        case 'A':
            return 14;
        default:
        {
            bl=0;
            return 0;
        }
    }
}
```
### 2024.04.16 BOSS PRO
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
char baka[6][10];
char *p[6]={baka[0],baka[1],baka[2],baka[3],baka[4],baka[5]};
int bl=1;
char Cirno (char);
int Mystia (char*);
void Daichan (int);
void Rumia (int);
int Wriggle(int);
int Marisa(int);
int main(void)
{
    scanf("%s%s%s%s%s%s",baka[0],baka[1],baka[2],baka[3],baka[4],baka[5]);
    //Marisa(3);
    Marisa(6);
    Daichan (3);
    Rumia (3);
    //putchar('\n');
    Daichan (6);
    Rumia (6);
    if(bl==1)
    {
        if(Wriggle(3)<Wriggle(6))
            printf("Winner is B!\n");
        else if(Wriggle(3)>Wriggle(6))
            printf("Winner is A!\n");
        else
        {
            if(Cirno(p[0][0])>Cirno(p[3][0]))
                printf("Winner is A!\n");
            else if(Cirno(p[0][0])<Cirno(p[3][0]))
                printf("Winner is B!\n");
            else
            {
                if(Mystia(p[0]+1)>Mystia(p[3]+1))
                    printf("Winner is A!\n");
                else if(Mystia(p[0]+1)<Mystia(p[3]+1))
                    printf("Winner is B!\n");
                else
                {
                    if(Cirno(p[1][0])>Cirno(p[4][0]))
                        printf("Winner is A!\n");
                    else if(Cirno(p[1][0])<Cirno(p[4][0]))
                        printf("Winner is B!\n");
                    else
                    {
                        if(Mystia(p[1]+1)>Mystia(p[4]+1))
                            printf("Winner is A!\n");
                        else if(Mystia(p[1]+1)<Mystia(p[4]+1))
                            printf("Winner is B!\n");
                        else
                        {
                            if(Cirno(p[2][0])>Cirno(p[5][0]))
                                printf("Winner is A!\n");
                            else if(Cirno(p[2][0])<Cirno(p[5][0]))
                                printf("Winner is B!\n");
                            else
                            {
                                if(Mystia(p[2]+1)>Mystia(p[5]+1))
                                    printf("Winner is A!\n");
                                else if(Mystia(p[2]+1)<Mystia(p[5]+1))
                                    printf("Winner is B!\n");
                                else
                                    printf("Draw!\n");
                            }
                        }
                    }
                }
            }
        }
        printf("A: %s %s %s\n",p[0],p[1],p[2]);
        printf("B: %s %s %s\n",p[3],p[4],p[5]);
    }
    else
        printf("Input Error!\n");
    return 0;
}
char Cirno (char q)//杞崲sz澶у皬
{
    switch(q)
    {
        case 'H':return 'D';
        case 'S':return 'C';
        case 'D':return 'B';
        case 'C':return 'A';
        default:bl=0;return q;
    }
}
int Mystia (char* x)//杞寲JQKA澶у皬
{
    int v=atoi(x);
    if(v!=0)
    {
        switch(v)
        {
            case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return v;
            default:bl=0;return v;
        }
    }
    else
    {
        int w=(int)x[0];
        switch(w)
        {
            case 74:return 11;
            case 81:return 12;
            case 75:return 13;
            case 65:return 14;
            default:bl=0;return v;
        }
    }
}
void Daichan (int z)//鎺掑垪zm椤哄簭
{
    int i,j;
    for(i=z-3;i<z;i++)
    {
        for(j=i+1;j<z;j++)
        {
            if(Mystia(p[i]+1)<Mystia(p[j]+1))
            {
                //putchar('?');
                char *r;
                r=p[i];
                p[i]=p[j];
                p[j]=r;
            }
        }
        //printf("%s ",p[i]);
    }
}
void Rumia (int y)//鎺掑垪zm椤哄簭
{
    int k,l;
    k=0;
    for(k=y-3;k<y;k++)
    {
        for(l=k+1;l<y;l++)
        {
            if(Mystia(p[k]+1)==Mystia(p[l]+1))
            {
                if(Cirno(p[k][0])<Cirno(p[l][0]))
                {
                    char *t;
                    t=p[k];
                    p[k]=p[l];
                    p[l]=t;
                }
            }
        }
        //printf("%s ",p[k]);
    }
}
int Wriggle(int num)//鍒ゆ柇浼樺厛绾?
{
    int first=Mystia(p[num-3]+1);
    int second=Mystia(p[num-2]+1);
    int third=Mystia(p[num-1]+1);
    //printf("%d %d %d\n",first,second,third);
    if((p[num-3][0]==p[num-2][0])&&(p[num-2][0]==p[num-1][0]))
    {
        if ((first + 1 == second && second + 1 == third) || (first - 1 == second && second - 1 == third))
        {
            //printf("鍚岃姳椤篭n");
            return 5;
        }
    }
    else if((first==second)&&(second==third))
    {
        //printf("鐐稿脊\n");
        return 4;
    }
    else if ((first + 1 == second && second + 1 == third) || (first - 1 == second && second - 1 == third))
    {
        //printf("杩炵墝\n");
        return 3;
    }
    else if((first==second)||(first==third)||(second==third))
    {
        //printf("瀵瑰瓙\n");
        return 2;
    }
    else
    {
        return 1;
    }
    return 0;
}
int Marisa(int u)//鍒ゆ柇鏄惁閲嶇墝
{
    for(int r=0;r<3;r++)
    {
        for(int t=1;(r+t)<3;t++)
        {
            //printf("%s %s\n",p[r],p[r+t]);
            if(strcmp(p[r],p[r+t])==0)
            {
                //printf("瀵瑰瓙\n");
                //printf("%s %s\n",p[r],p[r+t]);
                bl=0;
            }
        }
    }
    //printf("%s %s\n",p[3],p[4]);
    for(int r=3;r<6;r++)
    {
        for(int t=1;(r+t)<6;t++)
        {
            //putchar('?');
            //printf("%s %s\n",p[r],p[r+t]);
            if(strcmp(p[r],p[r+t])==0)
            {
                //printf("瀵瑰瓙\n");
                //printf("%s %s\n",p[r],p[r+t]);
                bl=0;
            }
        }
    }
    return 0;
}
```
### 2024.05.02 大家一起做游戏
```
#include <stdio.h>
int kid =0;
int num =0;
int noob[1000];
int main(void)
{
    scanf("%d %d",&kid,&num);
    int k=kid;
    int m=1,n;
    if(num==1)
    {
        printf("The left child is NO %d.\n",kid);
        return 0;
    }
    while(k>1)
    {
        for(n=0;n<kid;n++)
        {
            if(noob[n]!='0')
            {
                if(m==num)
                {
                    m=0;
                    k--;
                }
                noob[n]=m+48;
                m++;
            }
        }
    }
    for(int p=0;p<kid;p++)
    {
        if(noob[p]!='0')
            printf("The left child is NO %d.\n",p+1);
    }
    return 0;
}
```
### 2024.05.15 机动车尾号
```
#include <stdio.h>
int main (void)
{
    int y,m,d;
    int i=0;
    scanf("%d %d %d",&y,&m,&d);
    for(int n=y-1;n>=2012;n--)
    {
        if((n%4==0&&n%100!=0)||n%400==0)
            i+=2;
        else
            i++;
    }
    printf("%d\n",i);
}
```

### 2024.05.20 爱刷题的大神/注释损坏
```
/*ORZ Cirno BaKa*/
#include <stdio.h>
#include <string.h>
typedef struct cirno
{
    int nu,sc;
}MAN;
void quick_sort(MAN noob[100], int l, int r);
int main(void)
{
    char file[100];
    scanf("%s",file);
    FILE *fp=NULL;
    fp = fopen(file,"r");
    int num=0;
    fscanf(fp,"%d",&num);
    for(int n=0;n<num;n++)
    {
        int qiz=0;
        fscanf(fp,"%d",&qiz);
        struct cirno baka[100];
        for(int q=0;q<qiz;q++)
            fscanf(fp,"%d %d",&baka[q].nu,&baka[q].sc);
        int q;
        for(q=0;q<qiz;q++)
            if(baka[q].sc>=100)
                break;
        if(q==qiz)
        {
            printf("This OJ is too easy for PQ Dashen!\n");
            continue;
        }
        quick_sort(baka,0,qiz);
        for(q=0;q<qiz;q++)
            printf("%d\n",baka[q].nu);
        
        if(n<num-1)
            printf("\n");
    }
    fclose(fp);
}
//蹇€熸帓搴?
void quick_sort(MAN noob[100], int l, int r)
{
    if (l < r)
    {
        //Swap(s[l], s[(l + r) / 2]); //灏嗕腑闂寸殑杩欎釜鏁板拰绗竴涓暟浜ゆ崲 鍙傝娉?
        int i = l, j = r, x = noob[l].sc;
        while (i < j)
        {
            while(i < j && noob[j].sc >= x) // 浠庡彸鍚戝乏鎵剧涓€涓皬浜巟鐨勬暟
                j--;
            if(i < j)
                noob[i++].sc = noob[j].sc;
            
            while(i < j && noob[i].sc < x) // 浠庡乏鍚戝彸鎵剧涓€涓ぇ浜庣瓑浜巟鐨勬暟
                i++;
            if(i < j)
                noob[j--].sc = noob[i].sc;
        }
        noob[i].sc = x;
        quick_sort(noob, l, i - 1); // 閫掑綊璋冪敤
        quick_sort(noob, i + 1, r);
    }
}
```
### 2024.05.20 不高兴的女朋友/520限定
```
#include <stdio.h>
int main (void)
{
    struct cirno
    {
        int w,s;
    };
    struct cirno baka[7];
    for(int n=0;n<7;n++)
        scanf("%d %d",&baka[n].w,&baka[n].s);
    int max,m,d=0;
    for(m=0,max=0;m<7;m++)
    {
        if((baka[m].w)+(baka[m].s)>max)
        {
            d=m;
            max=(baka[m].w)+(baka[m].s);
        }
        if(max<10)
            d=-1;
    }
    printf("%d\n",d+1);
}
```
### 2024.05.27 恭喜发财
```
#include <stdio.h>
#include <string.h>
int main(void)
{
    int num=0;
    scanf("%d",&num);
    struct cirno
    {
        char name[100];
        int mo,give,gi;
        char giname[100][100];
    };
    struct cirno baka[num];
    for(int n=0;n<num;n++)
        scanf("%s",baka[n].name);
    for(int n=0;n<num;n++)
    {
        char na[100];
        int p=0;
        scanf("%s",na);
        for(int m=0;m<num;m++)
            if(strcmp(na,baka[m].name)==0)
            {
                p=m;
                break;
            }
        scanf("%d %d",&baka[p].mo,&baka[p].give);
        for(int t=0;t<baka[p].give;t++)
            scanf("%s",baka[p].giname[t]);
    }
    
    for(int n=0;n<num;n++)
    {
        if(baka[n].give!=0)
            baka[n].gi=baka[n].mo/baka[n].give;
        else
            baka[n].gi=0;
        baka[n].mo=0;
    }
    for(int n=0;n<num;n++)
    {
        for (int q=0;q<baka[n].give;q++)
        {
            int p=0;
            for(int m=0;m<num;m++)
                if(strcmp(baka[n].giname[q],baka[m].name)==0)
                {
                    p=m;
                    break;
                }
            baka[p].mo+=baka[n].gi;
            //baka[n].mo-=baka[n].gi;
        }
    }
    for(int q=0;q<num;q++)
        printf("%s %d\n",baka[q].name,baka[q].mo-(baka[q].give*baka[q].gi));
}
```
### 2024.05.28 拱猪计分
```
#include <stdio.h>
typedef struct cirno{
    int num;
    char card[1000][10];
}MAN;
int bl=0;
struct cirno baka[4];
int rumia (MAN);
int main (void)
{
    while(!bl)
    {
        for(int n=0,bl=0;n<4;n++)
        {
            scanf("%d",&baka[n].num);
            if(baka[n].num==0)
                bl++;
            if(bl==4)
                return 0;
            for(int m=0;m<baka[n].num;m++)
                scanf("%s",baka[n].card[m]);
        }
        for(int n=0;n<4;n++)
        {
            if(rumia(baka[n])>0)
                printf("+%d",rumia(baka[n]));
            else
                printf("%d",rumia(baka[n]));
            if(n<3)
                printf(" ");
        }
        printf("\n");
    }
}
int rumia (MAN noob)
{
    int red=0,bei=0,zhu=0,yag=0;
    int sc=0,b=1;
    for(int n=0;n<noob.num;n++)
    {
        if(noob.card[n][0]=='H')
            red++;
        if(noob.card[n][0]=='C'&&noob.card[n][1]=='1'&&noob.card[n][2]=='0')
            bei++;
        if(noob.card[n][0]=='D'&&noob.card[n][1]=='1'&&noob.card[n][2]=='1')
            yag++;
        if(noob.card[n][0]=='S'&&noob.card[n][1]=='1'&&noob.card[n][2]=='2')
            zhu++;
    }
    if(red==0&&zhu==0&&yag==0&bei==0)
        return 0;
    if(red==0&&zhu==0&&yag==0&bei==1)
        return 50;
    if(zhu==1&&yag==1&&red==13)
        sc+=500;
    else if(red==13)
        sc+=200;
    else
    {
        for(int n=0;n<noob.num;n++)
        {
            if(noob.card[n][0]=='H')
            {
                if(noob.card[n][2]=='\0')
                {
                    switch (noob.card[n][1])
                    {
                        case '1':sc-=50;break;
                        case '2':sc-=2;break;
                        case '3':sc-=3;break;
                        case '4':sc-=4;break;
                        case '5':sc-=5;break;
                        case '6':sc-=6;break;
                        case '7':sc-=7;break;
                        case '8':sc-=8;break;
                        case '9':sc-=9;break;
                    }
                }
                else
                {
                    switch (noob.card[n][2])
                    {
                        case '0':sc-=10;break;
                        case '1':sc-=20;break;
                        case '2':sc-=30;break;
                        case '3':sc-=40;break;
                    }
                }
            }
        }
    }
    if(zhu==1)
        sc-=100;
    if(yag==1)
        sc+=100;
    if(bei==1)
        b=2;
    return sc*b;
}
```
### 2024.05.19 机智的大师
```
#include <stdio.h>
int main (void)
{
    int num=0,rp=0,min=100000,mi=-1;
    scanf("%d %d",&num,&rp);
    int baka[num];
    for(int n=0;n<num;n++)
        scanf("%d",&baka[n]);
    for(int m=0;m<num;m++)
    {
        mi=-1;min=100000;
        for(int n=0;n<num;n++)
            if(baka[n]-rp<=min&&baka[n]-rp>=0)
            {
                min=baka[n]-rp;
                mi=n;
            }
        if(mi>=0)
        {
            rp+=2;
            baka[mi]=0;
        }
        else
        {
            for(int p=0;p<num;p++)
                if(baka[p]!=0)
                {
                    rp++;
                    baka[p]=0;
                    break;
                }
        }
    }
    printf("%d\n",rp);
}
```
### 2024.06.11 安全的密码
```
#include <stdio.h>
#include <string.h>
int cirno (char*);
int main(void) 
{
	int num;
	scanf("%d",&num);
	getchar();
	while(num-->0)
	{
		char baka[100]={0};
		gets(baka);
		if(strlen(baka)<6)
			printf("Not Safe\n");
		else
			cirno(baka);
	}
	return 0;
}
int cirno (char* busu)
{
	int nu=0,en=0,es=0,caps=0;
	for(int n=0;n<strlen(busu);n++)
	{
		if((busu[n]>='!'&&busu[n]<='/')||(busu[n]>=':'&&busu[n]<='@')||(busu[n]>='['&&busu[n]<='`')||(busu[n]==' '))
			es=1;
		else if(busu[n]>='0'&&busu[n]<='9')
			nu=1;
		else if(busu[n]>='a'&&busu[n]<='z')
			en=1;
		else if((busu[n]>='A'&&busu[n]<='Z'))
			caps=1;
	}
	//printf("%d %d %d\n",nu,en,es);
	if(nu+en+es+caps==1)
		printf("Not Safe\n");
	else if(nu+en+es+caps==2)
		printf("Medium Safe\n");
	else if(nu+en+es+caps>=3)
		printf("Safe\n");
	return 0;
}
```
### 2024.06.11 全能的战士
```
#include<stdio.h>
int main(void){
	int n,n1,n2,n3,n12,n13,n23;
	scanf("%d %d %d %d %d %d %d",&n,&n1,&n2,&n3,&n12,&n13,&n23);
	printf("%d\n",n-(n1+n2+n3-n12-n13-n23));
	return 0;
}
```
### 2024.06.12 凯撒密码
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int change (char*);
int seed (int);
int sort (int*,int);
char* outPut(char*,int);
int main (void)
{
	char Rome[1000];
	char Txt[10000];
	int Num[25];
	scanf("%s",Rome);
	for(int p=0;p<25;p++)
		scanf("%d",&Num[p]);
	int key=sort(Num,seed(change(Rome)));
	getchar();
	gets(Txt);
	puts(outPut(Txt,key));
}
int change (char* str)
{
	int pst=0,now=0,tmp,tot=0;
	for(int n=0;n<strlen(str);n++)
	{
		switch(str[n])
		{
			case 'I':now=1;break;
			case 'V':now=5;break;
			case 'X':now=10;break;
			case 'L':now=50;break;
			case 'C':now=100;break;
			case 'D':now=500;break;
			case 'M':now=1000;break;
			default:break;
		}
		tmp=now;
		if(pst<now&&pst!=0)
			now=now-2*pst;
		pst=tmp;
		tot+=now;
	}
	return tot;
}
int seed (int s)
{
	while(1)
	{
		int sed=0;
		for(int n=1;;n*=10)
		{
			if(s%n==s)
				break;
			sed+=s/n%10;
		}
		s=sed;
		if(sed%10==sed)
			return sed;
	}
}
int sort (int* it,int sed)
{
	for(int i=0;i<25;i++)
	{
		for(int j=0;j<25-i-1;j++)
		{
			if(it[j]>it[j+1])
			{
				int tmp=it[j];
				it[j]=it[j+1];
				it[j+1]=tmp;	
			}
		}
	}
	return it[sed-1];
}
char* outPut(char* txt,int key)
{
	int swch=key%26;
	printf("%d\n",swch);
	for(int n=0;n<strlen(txt);n++)
	{
		if(txt[n]>='a'&&txt[n]<='z')
		{
			if((int)txt[n]+swch>122)
				txt[n]+=(swch-26);
			else
				txt[n]+=swch;
		}
	}
	return txt;
}
```
### 2024.06.13 最短路径
```
#include <stdio.h>
int main(void)
{
	int x1,y1;
	int x2,y2;
	scanf("%d %d %d %d",&x2,&y2,&x1,&y1);
	if(x1==0&&x2==0&&y1==0&&y2==0)
	{
		printf("1\n(0,0)\n");
		return 0;
	}
	int fst=0,sec=0;
	int mid1,mid2;
	mid1=(x1-1)*(y1-1);
	mid2=(x2-x1-1)*(y2-y1-1);
	if(mid2<0)
		mid2/=-1;
	fst=x1*y1;
	sec=(x2-x1)*(y2-y1);
	if(sec<0)
		sec/=-1;
	printf("%d\n",(fst+1+mid1)*(sec+1+mid2));
	int x=0,y=0;
	for(int n=0;;n++)
	{
		if(x==x1&&y==y1)
			break;
		printf("(%d,%d)",x,y);
		if(x==x1)
			y++;
		else
			x++;
	}
	x=x1,y=y1;
	for(int n=0;;n++)
	{
		printf("(%d,%d)",x,y);
		if(x==x2&&y==y2)
			break;
		if(x==x2)
			y++;
		else
			x++;
	}
	printf("\n");
	return 0;
}
```
### 2024.06.25 大家一起做游戏/小学生
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct node
{
	char busu[6];
	struct node * next;
} NODE;

NODE * head;
NODE * end;
NODE * mid;
void import (char *);
void subtract (int);
int main (void)
{
	int n;
	scanf("%d",&n);
	int baka[n];
	for(int m=0;m<n;m++)
		scanf("%d",&baka[m]);
	mid = (NODE *)malloc( sizeof(NODE) );  
    mid->next = NULL;  
    strcpy(mid->busu,"eijuy");  
    
    head = (NODE *)malloc( sizeof(NODE) );
    head->next = mid;
    strcpy(head->busu,"-1");  
    
    for(int p=0;p<n;p++)
    {
    	char name[100];
    	scanf("%s",name);
    	import(name);
	}

	end = (NODE *)malloc( sizeof(NODE) );  
	head->next->next=end;
    end->next = NULL;  
    strcpy(end->busu,"vrqfb");
    
    for(int q=0;q<n;q++)
    {
    	int flag=0;
    	if(q!=0)
    	{
    		for(int x=q;x>=0;x--)
    			if(baka[x]<baka[q])
    				flag++;
    		subtract(baka[q]-flag);
    	}
    	else
    		subtract(baka[0]);
	}
}
void import (char *name)
{
	while(head->next!=NULL)
        head=head->next;
    NODE* p=(NODE*)malloc(sizeof(NODE));
    strcpy(p->busu,name);
    p->next=NULL;
    head->next=p;
    return 0;
}
void subtract (int baka)
{
	int count=0;
	NODE * p;
	NODE * q;
	p=mid;
	while(count<baka-1)
	{
		p = p->next;
		count++;
	}
	q=p->next;
    p->next=q->next;
    printf("%s %s\n",p->busu,q->next->busu);
    free(q);
    return 0;
}
```
### 2024.06.25 开大招
```
#include <stdio.h>
#include <string.h>//AWQEWAEQWQEE
int judge (char);
int count=1;
int Qcd=0,Wcd=0,Ecd=0,Acd=0;
char lst;
int main()
{
	char skill[1000];
	scanf("%s",skill);
	lst=skill[0];
	for(int n=1;n<strlen(skill);n++)
	{
		judge(skill[n]);
		if(Qcd>0)
			Qcd--;
		if(Wcd>0)
			Wcd--;
		if(Ecd>0)
			Ecd--;
		if(Acd>0)
			Acd--;
		if(count>=6)
			break;
	}
	char bol;
	if(count>5)
		bol='Y';
	else
		bol='N'; 
	printf("%d %c\n",count,bol);
	return 0;
}
int judge (char c)
{
	int bl=0;
	switch(c)
	{
		case 'Q':
			if(Qcd==0)
			{
				bl=1;
				Qcd+=2;
			}
			break;
		case 'W':
			if(Wcd==0)
			{
				bl=1;
				Wcd+=4;
			}
			break;
		case 'E':
			if(Ecd==0)
			{
				bl=1;
				Ecd+=3;
			}
			break;
		case 'A':
			if(Acd==0)
			{
				bl=1;
				Acd+=1;
			}
			break;
	}
	if(bl==1)
		if(c!=lst)
		{
			count++;
			lst=c;
		}
	return 0;
}
```
### 2024.06.25 象棋中的马/没做完
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */  
 
#include<stdio.h>   
int n,m,x,y,a[401][401];  
void dfs(int x,int y,int step);  
int main(){  
    scanf("%d%d",&n,&m);  
    for(int i=0;i<401;i++)  
    for(int j=0;j<401;j++)  
    a[i][j]=-1;//这里初始化-1 表示为无法到达   
    dfs(1,1,0);  
    for(int i=1;i<=n;i++){  
    for(int j=1;j<=m;j++)  
    printf("%5d",a[i][j]);  
    printf("\n");  
    }  
    return 0;  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */ 
}  
void dfs(int x,int y,int step)
{
	if(step>n*m)
	    return 0;
	if(x>m||y>n||x<=0||y<=0)
		return 0;
	if(a[x][y]>step||a[x][y]==-1)
		a[x][y]=step;

	
	
	int dub=step;
	dfs(x+2,y+1,++step);
	step=dub;
	dfs(x+2,y-1,++step);
	step=dub;
	dfs(x-2,y+1,++step);
	step=dub;
	dfs(x-2,y-1,++step);
	step=dub;
	dfs(x+1,y+2,++step);
	step=dub;
	dfs(x-1,y+2,++step);
	step=dub;
	dfs(x+1,y-2,++step);
	step=dub;
	dfs(x-1,y-2,++step);
	return 0;
}
```

## **递归题**
### 2024.05.08 回文字符/递归
```
#include <stdio.h>//TENET
#include <string.h>
char baka[100];
int cirno(char*,int);
int main(void)
{
    gets(baka);
    cirno(baka,0);
}
int cirno(char* busu,int n)
{
    
    if(busu[n]==busu[strlen(busu)-n-1])
    {
        if(n==strlen(busu)/2)
        {
            printf("Yes\n");
            return 0;
        }
        cirno(busu,n+1);
    }
    else
        printf("No\n");
    return 0;
}
```
### 2024.05.13 迭代求平方根
```
#include <stdio.h>
double x=0.0,p=0.0;
float e=0.0;
double cirno (double);
int main (void)
{
    scanf("%lf %g",&x,&e);
    p=e;
    printf("%.8lf\n",cirno(p));
}
double cirno(double q)
{
    if((q*q-x)*(q*q-x)<(e*e))
        return q;
    else
        return cirno(0.5*(q+(x/q)));
}
```
### 2024.06.13 递归函数
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */  
 
#include <stdio.h>  
void PrintChar(int number,char c){  
    int i;  
    for ( i=0 ; i< number; i++)  
        printf("%c",c);  
}  
 
// ????-----------???? 
char RecursionFunction(int n, char c);  
  
int main(){  
    char c; int n;  
    scanf("%d %c",&n,&c);  
    RecursionFunction(n,c);  
    return 0;  
}  
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */  
char RecursionFunction(int n, char c)
{
	if(n<=0)
	{
		printf("\n");
		printf("RecursionFunction has been over !\n");
		return 0;
	}
	PrintChar(n,c);
	switch(c)
	{
		case '#':n-=1;c='*';break;
		case '*':n+=2;c='?';break;
		case '?':n+=3;c='+';break;
		case '+':n-=6;c='#';break;
	}
	RecursionFunction(n,c);
}
```

## **链表题**
### 2024.06.03 交替插入链表
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */
 
#include "stdio.h"
#include "stdlib.h"
  
struct node
{   int data;
    struct node * next;
} ;
  
typedef struct node NODE;
typedef struct node * PNODE;
void outlist( PNODE );
void createList(PNODE);
void deployList(PNODE head1,PNODE head2,PNODE head3);
  
int main ( )
{   int num=1;
    PNODE head1,head2,head3;
  
    head1 = (PNODE)malloc( sizeof(NODE) );
    head1->next = NULL;
    head1->data = -1;
      
    head2 = (PNODE)malloc( sizeof(NODE) );
    head2->next = NULL;
    head2->data = -1;
  
    head3 = (PNODE)malloc( sizeof(NODE) );
    head3->next = NULL;
    head3->data = -1;
  
    createList(head1);// 杩欐槸浣犺瀹屾垚鐨勫嚱鏁?
    createList(head2);// 杩欐槸浣犺瀹屾垚鐨勫嚱鏁?
    deployList(head1,head2,head3);// 杩欐槸浣犺瀹屾垚鐨勫嚱鏁?
    outlist( head1 );
    return 0;
}
  
void outlist( PNODE head )
{   PNODE p;
    p = head->next;
    while ( p != NULL )
    {   printf("%d\n", p->data);
        p = p->next;
    }
}
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */

void createList(PNODE head)
{
    int num;
    PNODE p = NULL;

    scanf("%d", &num);
    while (num != 0)
    {
        while(head->next!=NULL)
            head=head->next;
        p = (PNODE)malloc(sizeof(NODE));
        p->data = num;
        p->next = head->next;
        head->next = p;

        scanf("%d", &num);
    }
}

void deployList(PNODE head1, PNODE head2, PNODE head3)
{
    PNODE p1 = head1->next;
    PNODE p2 = head2->next;
    PNODE p3 = head3;

    while (p1 != NULL && p2 != NULL)
    {
        p3->next = p1;
        p1 = p1->next;
        p3 = p3->next;
        
        p3->next = p2;
        p2 = p2->next;
        p3 = p3->next;
    }
    if (p1 != NULL)
        p3->next = p1;
   
    if (p2 != NULL)
        p3->next = p2;
}
```
### 2024.06.11 链表小数节点
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */
 
#include <stdio.h>
#include <stdlib.h>

int st=0,ed=0;
typedef struct node
{   int         data;
    struct node * next;
} NODE;
  
NODE * find( NODE * , int * );
void outputring( NODE * );
void change( int , int , NODE * );
  
void outputring( NODE * pring )
{
    NODE * p;
    p = pring;
    //printf("ass%d", p->data);
    if ( p == NULL )
        printf("NULL");
    else
        do
        {
            printf("%d", p->data);
            p = p->next;
            if(p==NULL){
                break;
            }
        }while(p!= pring);
    printf("\n");
    return;
  
}
  
int main()
{   int n, m;
    NODE * head, * pring;
  
    scanf("%d%d", &n, &m);
    head = (NODE *)malloc( sizeof(NODE) );
    head->next = NULL;
    head->data = -1;
  
    change( n, m, head );
    pring = find( head, &n );
    printf("ring=%d\n", n);
    outputring( pring );
  
    return 0;
}
  
/* Here is waiting for you.
void change( int n, int m, NODE * head )
{
}
 
NODE * find( NODE * head, int * n )
{
}
*/
  
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
void change( int n, int m, NODE * head )
{
    int sh[1000]={0};
    int mo[1000]={0};
    int bl=0;
    for(int i=0;;i++)
    {
        sh[i]=n*10/m;
        mo[i]=n*10%m;
        for(int j=0;j<i;j++)
            if(sh[i]==sh[j]&&mo[i]==mo[j])
            {
                st=j;
                ed=i;
                bl=1;
                break;
            }
        n=mo[i];
        
        
        if(n==0)
        {
            st=i+1;
            break;
        }
        if(bl!=0)
            break;
    }
    
    for(int k=0;k<st;k++)
    {
        while(head->next!=NULL)
            head=head->next;
        NODE* p=(NODE*)malloc(sizeof(NODE));
        p->data=sh[k];
        p->next=NULL;
        head->next=p;
    }
    if(bl!=0)
    {
        for(int k=st;k<ed;k++)
        {
            while(head->next!=NULL)
                head=head->next;
            NODE* p=(NODE*)malloc(sizeof(NODE));
            p->data=sh[k];
            p->next=NULL;
            head->next=p;
        }
    }
}

NODE * find( NODE * head, int * n )
{
    if(ed>st)
    {
        *n=ed-st;
        NODE* a=head->next;
        for(int k=0;k<st;k++)
            a=a->next;
        //printf("ass%d",a->data);
        return a;
    }
    else
    {
        *n=0;
        return NULL;
    }
}
```
### 2024.06.12 链表查找
```
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */  
  
#include <stdio.h>  
#include <stdlib.h>  
  
int st=0,ed=0;  
typedef struct node  
{   int         data;  
    struct node * next;  
} NODE;  
    
NODE * find( NODE * , int * );  
void outputring( NODE * );  
void change( int , int , NODE * );  
    
void outputring( NODE * pring )  
{  
    NODE * p;  
    p = pring;  
    //printf("ass%d", p->data);  
    if ( p == NULL )  
        printf("NULL");  
    else  
        do  
        {  
            printf("%d", p->data);  
            p = p->next;  
            if(p==NULL){  
                break;  
            }  
        }while(p!= pring);  
    printf("\n");  
    return;  
    
}  
    
int main()  
{   int n, m;  
    NODE * head, * pring;  
    
    scanf("%d%d", &n, &m);  
    head = (NODE *)malloc( sizeof(NODE) );  
    head->next = NULL;  
    head->data = -1;  
    
    change( n, m, head );  
    pring = find( head, &n );  
    printf("ring=%d\n", n);  
    outputring( pring );  
    
    return 0;  
}  
    
/* Here is waiting for you. 
void change( int n, int m, NODE * head ) 
{ 
} 
  
NODE * find( NODE * head, int * n ) 
{ 
} 
*/  
    
/* PRESET CODE END - NEVER TOUCH CODE ABOVE */  
void change( int n, int m, NODE * head )  
{  
    int sh[1000]={0};  
    int mo[1000]={0};  
    int bl=0;  
    for(int i=0;;i++)  
    {  
        sh[i]=n*10/m;  
        mo[i]=n*10%m;  
        for(int j=0;j<i;j++)  
            if(sh[i]==sh[j]&&mo[i]==mo[j])  
            {  
                st=j;  
                ed=i;  
                bl=1;  
                break;  
            }  
        n=mo[i];  
          
          
        if(n==0)  
        {  
            st=i+1;  
            break;  
        }  
        if(bl!=0)  
            break;  
    }  
      
    for(int k=0;k<st;k++)  
    {  
        while(head->next!=NULL)  
            head=head->next;  
        NODE* p=(NODE*)malloc(sizeof(NODE));  
        p->data=sh[k];  
        p->next=NULL;  
        head->next=p;  
    }  
    if(bl!=0)  
    {  
        for(int k=st;k<ed;k++)  
        {  
            while(head->next!=NULL)  
                head=head->next;  
            NODE* p=(NODE*)malloc(sizeof(NODE));  
            p->data=sh[k];  
            p->next=NULL;  
            head->next=p;  
        }  
    }  
}  
  
NODE * find( NODE * head, int * n )  
{  
    if(ed>st)  
    {  
        *n=ed-st;  
        NODE* a=head->next;  
        for(int k=0;k<st;k++)  
            a=a->next;  
        //printf("ass%d",a->data);  
        return a;  
    }  
    else  
    {  
        *n=0;  
        return NULL;  
    }  
}
```

# **其他**
## emm暂无,The Akina histroy goes on~
